/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MetaBindPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/settings/Settings.ts
var import_obsidian = require("obsidian");

// src/parsers/DateParser.ts
var Date = class {
  constructor() {
    this._monthMap = {
      1: "January",
      2: "February",
      3: "March",
      4: "April",
      5: "May",
      6: "June",
      7: "July",
      8: "August",
      9: "September",
      10: "October",
      11: "November",
      12: "December"
    };
    this._monthMapShort = {
      1: "Jan",
      2: "Feb",
      3: "Mar",
      4: "Apr",
      5: "May",
      6: "Jun",
      7: "Jul",
      8: "Aug",
      9: "Sep",
      10: "Oct",
      11: "Nov",
      12: "Dec"
    };
    this.setDay(DateParser.getDefaultDay());
    this.setMonth(DateParser.getDefaultMonth());
    this.setYear(DateParser.getDefaultYear());
  }
  getDay() {
    return this._day;
  }
  setDay(value) {
    if (value < 1 || value > 31) {
      return;
    }
    this._day = value;
  }
  getMonth() {
    return this._month;
  }
  setMonth(value) {
    if (value < 1 || value > 12) {
      return;
    }
    this._month = value;
  }
  getYear() {
    return this._year;
  }
  setYear(value) {
    this._year = value;
  }
  getUniformDay() {
    return ("00" + this.getDay().toString()).slice(-2);
  }
  getUniformMonth() {
    return ("00" + this.getMonth().toString()).slice(-2);
  }
  getUniformYear() {
    return ("0000" + this.getYear().toString()).slice(-4);
  }
  setDayFromString(str) {
    let v = Number.parseInt(str);
    this.setDay(Number.isNaN(v) ? DateParser.getDefaultDay() : v);
  }
  setMonthFromString(str) {
    let v = Number.parseInt(str);
    this.setMonth(Number.isNaN(v) ? DateParser.getDefaultMonth() : v);
  }
  setYearFromString(str) {
    let v = Number.parseInt(str);
    this.setYear(Number.isNaN(v) ? DateParser.getDefaultYear() : v);
  }
  getMonthName() {
    return this._monthMap[this.getMonth()];
  }
  getMonthNameShort() {
    return this._monthMapShort[this.getMonth()];
  }
  setMonthFromName(name) {
    for (const [key, value] of Object.entries(this._monthMap)) {
      if (value === name) {
        this.setMonthFromString(key);
        return;
      }
    }
    for (const [key, value] of Object.entries(this._monthMapShort)) {
      if (value === name) {
        this.setMonthFromString(key);
        return;
      }
    }
  }
};
var DateParser = class {
  static stringify(date) {
    if (DateParser.dateFormat === "us" /* US */) {
      return DateParser.stringifyUsDate(date);
    } else if (DateParser.dateFormat === "eu" /* EU */) {
      return DateParser.stringifyEuDate(date);
    } else if (DateParser.dateFormat === "f_us" /* FANCY_US */) {
      return DateParser.stringifyUsFancyDate(date);
    } else if (DateParser.dateFormat === "fs_us" /* FANCY_SHORT_US */) {
      return DateParser.stringifyUsFancyDateShort(date);
    }
  }
  static parse(dateString) {
    if (DateParser.dateFormat === "us" /* US */) {
      return DateParser.parseUsDate(dateString);
    } else if (DateParser.dateFormat === "eu" /* EU */) {
      return DateParser.parseEuDate(dateString);
    } else if (DateParser.dateFormat === "f_us" /* FANCY_US */) {
      return DateParser.parseUsFancyDate(dateString);
    } else if (DateParser.dateFormat === "fs_us" /* FANCY_SHORT_US */) {
      return DateParser.parseUsFancyDate(dateString);
    }
  }
  static stringifyEuDate(date) {
    return `${date.getUniformDay()}/${date.getUniformMonth()}/${date.getUniformYear()}`;
  }
  static parseEuDate(dateString) {
    const date = DateParser.getDefaultDate();
    const dateParts = dateString.split("/");
    if (dateParts.length !== 3) {
      return null;
    }
    date.setDayFromString(dateParts[0]);
    date.setMonthFromString(dateParts[1]);
    date.setYearFromString(dateParts[2]);
    return date;
  }
  static stringifyUsDate(date) {
    return `${date.getUniformMonth()}/${date.getUniformDay()}/${date.getUniformYear()}`;
  }
  static parseUsDate(dateString) {
    const date = DateParser.getDefaultDate();
    const dateParts = dateString.split("/");
    if (dateParts.length !== 3) {
      return null;
    }
    date.setMonthFromString(dateParts[0]);
    date.setDayFromString(dateParts[1]);
    date.setYearFromString(dateParts[2]);
    return date;
  }
  static stringifyUsFancyDate(date) {
    return `${date.getMonthName()} ${date.getDay().toString()}, ${date.getYear().toString()}`;
  }
  static stringifyUsFancyDateShort(date) {
    return `${date.getMonthNameShort()} ${date.getDay().toString()}, ${date.getYear().toString()}`;
  }
  static parseUsFancyDate(dateString) {
    const date = DateParser.getDefaultDate();
    const dateParts = dateString.split(",").map((x) => x.trim());
    if (dateParts.length !== 2) {
      return null;
    }
    const datePartsParts = dateParts[0].split(" ");
    if (datePartsParts.length !== 2) {
      return null;
    }
    date.setMonthFromName(datePartsParts[0]);
    date.setDayFromString(datePartsParts[1]);
    date.setYearFromString(dateParts[1]);
    return date;
  }
  static getDefaultDate() {
    return new Date();
  }
  static getDefaultDay() {
    return 1;
  }
  static getDefaultMonth() {
    return 1;
  }
  static getDefaultYear() {
    return 2022;
  }
};

// src/settings/Settings.ts
var DEFAULT_SETTINGS = {
  devMode: false,
  dateFormat: "us" /* US */,
  syncInterval: 200,
  minSyncInterval: 50,
  maxSyncInterval: 1e3
};
var MetaBindSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Meta Bind Plugin Settings" });
    new import_obsidian.Setting(containerEl).setName("Sync Interval").setDesc(`The interval in milli-seconds between disk writes. Changing this number is not recommended except if your hard drive is exceptionally slow. Standard: ${DEFAULT_SETTINGS.syncInterval}; Minimum: ${DEFAULT_SETTINGS.minSyncInterval}; Maximum: ${DEFAULT_SETTINGS.maxSyncInterval}`).addText((cb) => {
      cb.setValue(this.plugin.settings.syncInterval.toString());
      cb.onChange((data) => {
        this.plugin.settings.syncInterval = Number.parseInt(data);
        if (Number.isNaN(this.plugin.settings.syncInterval)) {
          this.plugin.settings.syncInterval = DEFAULT_SETTINGS.syncInterval;
        }
        if (this.plugin.settings.syncInterval < DEFAULT_SETTINGS.minSyncInterval) {
          this.plugin.settings.syncInterval = DEFAULT_SETTINGS.minSyncInterval;
        }
        if (this.plugin.settings.syncInterval > DEFAULT_SETTINGS.maxSyncInterval) {
          this.plugin.settings.syncInterval = DEFAULT_SETTINGS.maxSyncInterval;
        }
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Date format").setDesc(`The date format to be used by this plugin.`).addDropdown((cb) => {
      cb.addOptions({
        "us": "US date format (1/30/2022)",
        "eu": "EU date format (30/1/2022)",
        "f_us": "US date format (January 30, 2022)",
        "fs_us": "US date format (Jan 30, 2022)"
      });
      cb.onChange((data) => {
        this.plugin.settings.dateFormat = data;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Dev Mode").setDesc("Enable dev mode. Not recommended unless you want to debug this plugin.").addToggle((cb) => {
      cb.setValue(this.plugin.settings.devMode);
      cb.onChange((data) => {
        this.plugin.settings.devMode = data;
        this.plugin.saveSettings();
      });
    });
  }
};

// src/InputFieldMarkdownRenderChild.ts
var import_obsidian8 = require("obsidian");

// src/utils/Logger.ts
var _Logger = class {
  static log(...data) {
    console.log(this.prefix, ...data);
  }
  static logDebug(...data) {
    if (this.devMode) {
      _Logger.log(...data);
    }
  }
  static logWarning(...data) {
    console.warn(this.prefix, data);
  }
  static logError(...data) {
    console.error(this.prefix, data);
  }
};
var Logger = _Logger;
Logger.prefix = "meta-bind |";

// src/inputFields/AbstractInputField.ts
var AbstractInputField = class {
  constructor(inputFieldMarkdownRenderChild, onValueChange) {
    this.inputFieldMarkdownRenderChild = inputFieldMarkdownRenderChild;
    this.onValueChange = onValueChange;
  }
};
AbstractInputField.allowCodeBlock = true;
AbstractInputField.allowInlineCodeBlock = true;

// src/inputFields/ToggleInputField.ts
var import_obsidian2 = require("obsidian");
var ToggleInputField = class extends AbstractInputField {
  getValue() {
    return this.toggleComponent.getValue();
  }
  setValue(value) {
    if (value != null && typeof value == "boolean") {
      this.toggleComponent.setValue(value);
    } else {
      Logger.logWarning(`can not set value of toggle to '${value}'`);
      this.toggleComponent.setValue(false);
    }
  }
  isEqualValue(value) {
    return this.getValue() == value;
  }
  getDefaultValue() {
    return false;
  }
  getHtmlElement() {
    return this.toggleComponent.toggleEl;
  }
  render(container) {
    const component = new import_obsidian2.ToggleComponent(container);
    component.setValue(this.inputFieldMarkdownRenderChild.getInitialValue());
    component.onChange(this.onValueChange);
    this.toggleComponent = component;
  }
};

// src/inputFields/TextInputField.ts
var import_obsidian3 = require("obsidian");
var TextInputField = class extends AbstractInputField {
  getValue() {
    return this.textComponent.getValue();
  }
  setValue(value) {
    if (value != null && typeof value == "string") {
      this.textComponent.setValue(value);
    } else {
      Logger.logWarning(`can not set value of text input to '${value}'`);
      this.textComponent.setValue("");
    }
  }
  isEqualValue(value) {
    return this.getValue() == value;
  }
  getDefaultValue() {
    return "";
  }
  getHtmlElement() {
    return this.textComponent.inputEl;
  }
  render(container) {
    const component = new import_obsidian3.TextComponent(container);
    component.setValue(this.inputFieldMarkdownRenderChild.getInitialValue());
    component.onChange(this.onValueChange);
    this.textComponent = component;
  }
};

// src/inputFields/SliderInputField.ts
var import_obsidian4 = require("obsidian");
var SliderInputField = class extends AbstractInputField {
  constructor(inputFieldMarkdownRenderChild, onValueChange) {
    var _a, _b, _c, _d;
    super(inputFieldMarkdownRenderChild, onValueChange);
    this.minValue = (_b = (_a = inputFieldMarkdownRenderChild.getArgument("minValue")) == null ? void 0 : _a.value) != null ? _b : 0;
    this.maxValue = (_d = (_c = inputFieldMarkdownRenderChild.getArgument("maxValue")) == null ? void 0 : _c.value) != null ? _d : 100;
  }
  getValue() {
    return this.sliderComponent.getValue();
  }
  setValue(value) {
    if (value != null && typeof value == "number") {
      if (value >= this.minValue && value <= this.maxValue) {
        this.sliderComponent.setValue(value);
      }
    } else {
      Logger.logWarning(`can not set value of slider to '${value}'`);
      this.sliderComponent.setValue(this.getDefaultValue());
    }
  }
  isEqualValue(value) {
    return this.getValue() == value;
  }
  getDefaultValue() {
    return this.minValue;
  }
  getHtmlElement() {
    return this.sliderComponent.sliderEl;
  }
  render(container) {
    container.removeClass("meta-bind-plugin-input-wrapper");
    container.addClass("meta-bind-plugin-flex-input-wrapper");
    let labelArgument = this.inputFieldMarkdownRenderChild.getArgument("labels");
    if (labelArgument && labelArgument.value === true) {
      container.createSpan({ text: this.minValue.toString(), cls: "meta-bind-plugin-slider-input-label" });
    }
    const component = new import_obsidian4.SliderComponent(container);
    component.setValue(this.inputFieldMarkdownRenderChild.getInitialValue());
    component.onChange(this.onValueChange);
    component.setDynamicTooltip();
    component.setLimits(this.minValue, this.maxValue, 1);
    component.sliderEl.addClass("meta-bind-plugin-slider-input");
    if (labelArgument && labelArgument.value === true) {
      container.createSpan({ text: this.maxValue.toString(), cls: "meta-bind-plugin-slider-input-label" });
    }
    this.sliderComponent = component;
  }
};

// src/inputFields/TextAreaInputField.ts
var import_obsidian5 = require("obsidian");
var TextAreaInputField = class extends AbstractInputField {
  getValue() {
    return this.textAreaComponent.getValue();
  }
  setValue(value) {
    if (value != null && typeof value == "string") {
      this.textAreaComponent.setValue(value);
    } else {
      Logger.logWarning(`can not set value of text area input to '${value}'`);
      this.textAreaComponent.setValue("");
    }
  }
  isEqualValue(value) {
    return this.getValue() == value;
  }
  getDefaultValue() {
    return "";
  }
  getHtmlElement() {
    return this.textAreaComponent.inputEl;
  }
  render(container) {
    const component = new import_obsidian5.TextAreaComponent(container);
    component.setValue(this.inputFieldMarkdownRenderChild.getInitialValue());
    component.onChange(this.onValueChange);
    this.textAreaComponent = component;
  }
};

// src/inputFields/SelectInputFieldElement.ts
var SelectInputFieldElement = class {
  constructor(value, parentElement, id, multiSelectInputField, active = false) {
    this.value = value;
    this.id = id;
    this.active = active;
    this.selectInputField = multiSelectInputField;
    this.cssClass = "meta-bind-plugin-select-input-element";
    this.activeClass = "meta-bind-plugin-select-input-element-selected";
    this.hoverClass = "meta-bind-plugin-select-input-element-hover";
    this.element = parentElement.createDiv({ cls: this.cssClass });
    this.element.id = this.getHTMLId();
    this.element.on("click", "#" + this.getHTMLId(), () => {
      this.setActive(!this.active);
      if (!this.selectInputField.allowMultiSelect) {
        this.selectInputField.disableAllOtherElements(this.id);
      }
    });
    this.element.on("mouseenter", "#" + this.getHTMLId(), () => {
      this.setHighlighted(true);
    });
    this.element.on("mouseleave", "#" + this.getHTMLId(), () => {
      this.setHighlighted(false);
    });
  }
  getHTMLId() {
    return `meta-bind-select-input-element-${this.selectInputField.inputFieldMarkdownRenderChild.uid}-${this.id}`;
  }
  isHighlighted() {
    return this.highlighted;
  }
  setHighlighted(value) {
    this.highlighted = value;
    if (this.highlighted) {
      this.addClass(this.hoverClass);
      this.selectInputField.deHighlightAllOtherElements(this.id);
    } else {
      this.removeClass(this.hoverClass);
    }
  }
  isActive() {
    return this.active;
  }
  setActive(active, updateParent = true) {
    this.active = active;
    this.update(updateParent);
  }
  update(updateParent) {
    if (this.active) {
      this.addClass(this.activeClass);
    } else {
      this.removeClass(this.activeClass);
    }
    if (updateParent) {
      this.selectInputField.onChange();
    }
  }
  addClass(cssClass) {
    if (!this.element.hasClass(cssClass)) {
      this.element.addClass(cssClass);
    }
  }
  removeClass(cssClass) {
    if (this.element.hasClass(cssClass)) {
      this.element.removeClass(cssClass);
    }
  }
  render() {
    this.element.createEl("div", { text: this.value });
  }
};

// src/utils/Utils.ts
var MetaBindInternalError = class extends Error {
  constructor(message) {
    super(`[MB_INTERNAL_ERROR - please report this error here https://github.com/mProjectsCode/obsidian-meta-bind-plugin/issues] ${message}`);
  }
};
var MetaBindParsingError = class extends Error {
  constructor(message) {
    super(`[MB_PARSING_ERROR] ${message}`);
  }
};
var MetaBindBindTargetError = class extends Error {
  constructor(message) {
    super(`[MB_BIND_TARGET_ERROR] ${message}`);
  }
};
function getFileName(path) {
  return path.split("/").at(-1);
}
function isPath(path) {
  return path.split("/").length > 1;
}
function removeFileEnding(fileName) {
  const fileNameParts = fileName.split(".");
  if (fileNameParts.length === 1) {
    return fileName;
  } else {
    let newFileName = fileNameParts[0];
    for (let i = 1; i < fileNameParts.length - 1; i++) {
      newFileName += "." + fileNameParts[i];
    }
    return newFileName;
  }
}
function mod(n, m) {
  return (n % m + m) % m;
}
function arrayEquals(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (const arr1Element of arr1) {
    if (!arr2.contains(arr1Element)) {
      return false;
    }
  }
  return true;
}
function isTruthy(value) {
  return !!value;
}
function isFalsy(value) {
  return !value;
}
function equalOrIncludes(str1, str2) {
  return str1 === str2 || str1.includes(str2) || str2.includes(str1);
}

// src/inputFields/SelectInputField.ts
var SelectInputField = class extends AbstractInputField {
  constructor(inputFieldMarkdownRenderChild, onValueChange) {
    super(inputFieldMarkdownRenderChild, onValueChange);
    this.elements = [];
    this.allowMultiSelect = false;
  }
  getHtmlElement() {
    return this.container;
  }
  getValue() {
    var _a, _b;
    return (_b = (_a = this.elements.filter((x) => x.isActive()).first()) == null ? void 0 : _a.value) != null ? _b : "";
  }
  setValue(value) {
    for (const element of this.elements) {
      if (value === element.value) {
        element.setActive(true, false);
      } else {
        element.setActive(false, false);
      }
    }
  }
  isEqualValue(value) {
    return this.getValue() == value;
  }
  getDefaultValue() {
    return "";
  }
  onChange() {
    this.onValueChange(this.getValue());
  }
  render(container) {
    container.addClass("meta-bind-plugin-select-input-bg");
    this.container = container;
    const elementWrapper = container.createDiv({ cls: "meta-bind-plugin-select-input-wrapper" });
    const titleArgument = this.inputFieldMarkdownRenderChild.getArgument("title");
    if (titleArgument) {
      elementWrapper.createEl("div", { text: titleArgument.value, cls: "meta-bind-plugin-select-input-header" });
    }
    const elementArguments = this.inputFieldMarkdownRenderChild.getArguments("option");
    let i = 0;
    for (const elementArgument of elementArguments) {
      const selectInputFieldElement = new SelectInputFieldElement(elementArgument.value, elementWrapper, i, this, false);
      this.elements.push(selectInputFieldElement);
      selectInputFieldElement.render();
      i += 1;
    }
    this.setValue(this.inputFieldMarkdownRenderChild.getInitialValue());
  }
  disableAllOtherElements(elementId) {
    for (const selectModalElement of this.elements) {
      if (selectModalElement.id !== elementId) {
        selectModalElement.setActive(false);
      }
    }
  }
  deHighlightAllOtherElements(elementId) {
    for (const selectModalElement of this.elements) {
      if (selectModalElement.id !== elementId) {
        selectModalElement.setHighlighted(false);
      }
    }
  }
  activateHighlighted() {
    for (const selectModalElement of this.elements) {
      if (selectModalElement.isHighlighted()) {
        selectModalElement.setActive(!selectModalElement.isActive());
        if (!this.allowMultiSelect) {
          this.disableAllOtherElements(selectModalElement.id);
        }
      }
    }
  }
  highlightUp() {
    for (const selectModalElement of this.elements) {
      if (selectModalElement.isHighlighted()) {
        this.getPreviousSelectModalElement(selectModalElement).setHighlighted(true);
        return;
      }
    }
    this.elements.last().setHighlighted(true);
  }
  highlightDown() {
    for (const selectModalElement of this.elements) {
      if (selectModalElement.isHighlighted()) {
        this.getNextSelectModalElement(selectModalElement).setHighlighted(true);
        return;
      }
    }
    this.elements.first().setHighlighted(true);
  }
  getNextSelectModalElement(element) {
    let nextId = element.id + 1;
    nextId = mod(nextId, this.elements.length);
    return this.elements.filter((x) => x.id === nextId).first();
  }
  getPreviousSelectModalElement(element) {
    let nextId = element.id - 1;
    nextId = mod(nextId, this.elements.length);
    return this.elements.filter((x) => x.id === nextId).first();
  }
};
SelectInputField.allowInlineCodeBlock = false;

// src/inputFields/MultiSelectInputField.ts
var MultiSelectInputField = class extends SelectInputField {
  constructor(inputFieldMarkdownRenderChild, onValueChange) {
    super(inputFieldMarkdownRenderChild, onValueChange);
    this.allowMultiSelect = true;
  }
  getValue() {
    return this.elements.filter((x) => x.isActive()).map((x) => x.value);
  }
  setValue(value) {
    if (value.length === 0) {
      for (const element of this.elements) {
        element.setActive(false, false);
      }
      return;
    }
    elementLoop:
      for (const element of this.elements) {
        for (const valueElement of value) {
          if (valueElement === element.value) {
            element.setActive(true, false);
            continue elementLoop;
          }
        }
        element.setActive(false, false);
      }
  }
  isEqualValue(value) {
    if (!Array.isArray(value)) {
      return false;
    }
    return arrayEquals(this.getValue(), value);
  }
  getDefaultValue() {
    return [];
  }
};

// src/inputFields/DateInputField.ts
var import_obsidian6 = require("obsidian");
var DateInputField = class extends AbstractInputField {
  constructor(inputFieldMarkdownRenderChild, onValueChange) {
    super(inputFieldMarkdownRenderChild, onValueChange);
    this.months = {
      "1": "January",
      "2": "February",
      "3": "March",
      "4": "April",
      "5": "May",
      "6": "June",
      "7": "July",
      "8": "August",
      "9": "September",
      "10": "October",
      "11": "November",
      "12": "December"
    };
    this.days = {};
    for (let i = 1; i <= 31; i++) {
      this.days[i.toString()] = i.toString();
    }
  }
  getHtmlElement() {
    return this.container;
  }
  getValue() {
    return DateParser.stringify(this.date);
  }
  setValue(value) {
    this.date = DateParser.parse(value);
    this.monthComponent.setValue(this.date.getMonth().toString());
    this.dayComponent.setValue(this.date.getDay().toString());
    this.yearComponent.setValue(this.date.getYear().toString());
  }
  isEqualValue(value) {
    return value == this.getValue();
  }
  getDefaultValue() {
    return DateParser.stringify(DateParser.getDefaultDate());
  }
  render(container) {
    var _a;
    this.date = (_a = DateParser.parse(this.inputFieldMarkdownRenderChild.getInitialValue())) != null ? _a : DateParser.getDefaultDate();
    container.removeClass("meta-bind-plugin-input-wrapper");
    container.addClass("meta-bind-plugin-flex-input-wrapper", "meta-bind-plugin-input-element-group");
    if (DateParser.dateFormat === "eu" /* EU */) {
      this.dayComponent = new import_obsidian6.DropdownComponent(container);
      this.dayComponent.addOptions(this.days);
      this.dayComponent.setValue(this.date.getDay().toString());
      this.dayComponent.onChange(this.onDayChange.bind(this));
      this.monthComponent = new import_obsidian6.DropdownComponent(container);
      this.monthComponent.addOptions(this.months);
      this.monthComponent.setValue(this.date.getMonth().toString());
      this.monthComponent.onChange(this.onMonthChange.bind(this));
      this.dayComponent.selectEl.addClass("meta-bind-plugin-input-element-group-element");
      this.monthComponent.selectEl.addClass("meta-bind-plugin-input-element-group-element");
    } else {
      this.monthComponent = new import_obsidian6.DropdownComponent(container);
      this.monthComponent.addOptions(this.months);
      this.monthComponent.setValue(this.date.getMonth().toString());
      this.monthComponent.onChange(this.onMonthChange.bind(this));
      this.dayComponent = new import_obsidian6.DropdownComponent(container);
      this.dayComponent.addOptions(this.days);
      this.dayComponent.setValue(this.date.getDay().toString());
      this.dayComponent.onChange(this.onDayChange.bind(this));
      this.dayComponent.selectEl.addClass("meta-bind-plugin-input-element-group-element");
      this.monthComponent.selectEl.addClass("meta-bind-plugin-input-element-group-element");
    }
    this.yearComponent = new import_obsidian6.TextComponent(container);
    this.yearComponent.setValue(this.date.getYear().toString());
    this.yearComponent.onChange(this.onYearChange.bind(this));
    this.yearComponent.inputEl.addClass("meta-bind-plugin-date-input-year-input");
    this.yearComponent.inputEl.addClass("meta-bind-plugin-input-element-group-element");
    this.yearComponent.inputEl.type = "number";
    this.yearComponent.inputEl.max = "9999";
    this.container = container;
  }
  onMonthChange(value) {
    this.date.setMonthFromString(value);
    this.onValueChange(this.getValue());
  }
  onDayChange(value) {
    this.date.setDayFromString(value);
    this.onValueChange(this.getValue());
  }
  onYearChange(value) {
    this.date.setYearFromString(value);
    this.onValueChange(this.getValue());
  }
};

// src/inputFields/TimeInputField.ts
var import_obsidian7 = require("obsidian");

// src/parsers/TimeParser.ts
var Time = class {
  constructor() {
    this.setHour(TimeParser.getDefaultHour());
    this.setMinute(TimeParser.getDefaultMinute());
  }
  getHour() {
    return this._hour;
  }
  setHour(value) {
    if (value < 0 || value > 24) {
      return;
    }
    this._hour = value;
  }
  getMinute() {
    return this._minute;
  }
  setMinute(value) {
    if (value < 0 || value > 59) {
      return;
    }
    this._minute = value;
  }
  getUniformHour() {
    return ("00" + this.getHour().toString()).slice(-2);
  }
  getUniformMinute() {
    return ("00" + this.getMinute().toString()).slice(-2);
  }
  setHourFromString(str) {
    let v = Number.parseInt(str);
    this.setHour(Number.isNaN(v) ? TimeParser.getDefaultHour() : v);
  }
  setMinuteFromString(str) {
    let v = Number.parseInt(str);
    this.setMinute(Number.isNaN(v) ? TimeParser.getDefaultMinute() : v);
  }
};
var TimeParser = class {
  static parse(timeString) {
    const time = TimeParser.getDefaultTime();
    const timeParts = timeString.split(":");
    if (timeParts.length !== 2) {
      return null;
    }
    time.setHourFromString(timeParts[0]);
    time.setMinuteFromString(timeParts[1]);
    return time;
  }
  static stringify(time) {
    return `${time.getUniformHour()}:${time.getUniformMinute()}`;
  }
  static getDefaultTime() {
    return new Time();
  }
  static getDefaultHour() {
    return 0;
  }
  static getDefaultMinute() {
    return 0;
  }
};

// src/inputFields/TimeInputField.ts
var TimeInputField = class extends AbstractInputField {
  constructor(inputFieldMarkdownRenderChild, onValueChange) {
    super(inputFieldMarkdownRenderChild, onValueChange);
    this.hours = {};
    for (let i = 0; i <= 24; i++) {
      this.hours[i.toString()] = i.toString();
    }
    this.minutes = {};
    for (let i = 0; i <= 59; i++) {
      this.minutes[i.toString()] = i.toString();
    }
  }
  getHtmlElement() {
    return this.container;
  }
  getValue() {
    return TimeParser.stringify(this.time);
  }
  setValue(value) {
    this.time = TimeParser.parse(value);
    this.hourComponent.setValue(this.time.getHour().toString());
    this.minuteComponent.setValue(this.time.getMinute().toString());
  }
  isEqualValue(value) {
    return value == this.getValue();
  }
  getDefaultValue() {
    return TimeParser.stringify(TimeParser.getDefaultTime());
  }
  render(container) {
    var _a;
    this.time = (_a = TimeParser.parse(this.inputFieldMarkdownRenderChild.getInitialValue())) != null ? _a : TimeParser.getDefaultTime();
    container.removeClass("meta-bind-plugin-input-wrapper");
    container.addClass("meta-bind-plugin-flex-input-wrapper", "meta-bind-plugin-input-element-group");
    this.hourComponent = new import_obsidian7.DropdownComponent(container);
    this.hourComponent.addOptions(this.hours);
    this.hourComponent.setValue(this.time.getHour().toString());
    this.hourComponent.onChange(this.onHourChange.bind(this));
    this.minuteComponent = new import_obsidian7.DropdownComponent(container);
    this.minuteComponent.addOptions(this.minutes);
    this.minuteComponent.setValue(this.time.getMinute().toString());
    this.minuteComponent.onChange(this.onMinuteChange.bind(this));
    this.hourComponent.selectEl.addClass("meta-bind-plugin-input-element-group-element");
    this.minuteComponent.selectEl.addClass("meta-bind-plugin-input-element-group-element");
    this.container = container;
  }
  onHourChange(value) {
    this.time.setHourFromString(value);
    this.onValueChange(this.getValue());
  }
  onMinuteChange(value) {
    this.time.setMinuteFromString(value);
    this.onValueChange(this.getValue());
  }
};

// src/utils/ParserUtils.ts
var EnclosingPair = class {
  constructor(openingString, closingString) {
    if (isFalsy(openingString)) {
      throw new MetaBindInternalError("opening string must not be empty");
    }
    this.openingEqualsClosing = isFalsy(closingString) || openingString === closingString;
    this._openingString = openingString;
    this._closingString = closingString;
  }
  get openingString() {
    return this._openingString;
  }
  get closingString() {
    return this.openingEqualsClosing ? this._openingString : this._closingString;
  }
  overlaps(other) {
    return equalOrIncludes(this.openingString, other.openingString) || equalOrIncludes(this.openingString, other.closingString) || equalOrIncludes(this.closingString, other.openingString) || equalOrIncludes(this.closingString, other.closingString);
  }
  equals(other) {
    if (isFalsy(other)) {
      return false;
    }
    return this.openingString === other.openingString && this.closingString === other.closingString;
  }
  toString() {
    return JSON.stringify(this);
  }
};
var ParserUtils = class {
  static split(str, separator, ignore) {
    if (!str) {
      throw new MetaBindInternalError("string must not be empty");
    }
    if (!separator) {
      throw new MetaBindInternalError("separator must not be empty");
    }
    let subStr = "";
    let subStrings = [];
    if (ignore) {
      let remainingOpeningStringCount = ParserUtils.numberOfOccurrences(str, ignore.openingString);
      let remainingClosingStringCount = ParserUtils.numberOfOccurrences(str, ignore.closingString);
      let enclosingLevel = 0;
      strLoop:
        for (let i = 0; i < str.length; i++) {
          if (enclosingLevel === 0 && ParserUtils.isStringAt(str, separator, i)) {
            subStrings.push(subStr);
            subStr = "";
            i += separator.length - 1;
          } else {
            subStr += str[i];
          }
          if (ignore.openingEqualsClosing) {
            if (ParserUtils.isStringAt(str, ignore.openingString, i)) {
              if (enclosingLevel % 2 === 0 && remainingOpeningStringCount === 1) {
              } else if (enclosingLevel % 2 === 0) {
                enclosingLevel += 1;
                for (let j = 1; j < ignore.openingString.length; j++) {
                  i += 1;
                  subStr += str[i];
                  if (i >= str.length) {
                    break strLoop;
                  }
                }
              } else {
                enclosingLevel -= 1;
                for (let j = 1; j < ignore.closingString.length; j++) {
                  i += 1;
                  subStr += str[i];
                  if (i >= str.length) {
                    break strLoop;
                  }
                }
              }
              remainingOpeningStringCount -= 1;
            }
          } else {
            if (ParserUtils.isStringAt(str, ignore.openingString, i)) {
              if (remainingOpeningStringCount <= remainingClosingStringCount) {
                enclosingLevel += 1;
                for (let j = 1; j < ignore.openingString.length; j++) {
                  i += 1;
                  subStr += str[i];
                  if (i >= str.length) {
                    break strLoop;
                  }
                }
              }
              remainingOpeningStringCount -= 1;
            } else if (ParserUtils.isStringAt(str, ignore.closingString, i)) {
              if (enclosingLevel > 0) {
                enclosingLevel -= 1;
                for (let j = 1; j < ignore.closingString.length; j++) {
                  i += 1;
                  subStr += str[i];
                  if (i >= str.length) {
                    break strLoop;
                  }
                }
              }
              remainingClosingStringCount -= 1;
            }
          }
        }
    } else {
      for (let i = 0; i < str.length; i++) {
        if (ParserUtils.isStringAt(str, separator, i)) {
          subStrings.push(subStr);
          subStr = "";
          i += separator.length - 1;
        } else {
          subStr += str[i];
        }
      }
    }
    subStrings.push(subStr);
    return subStrings;
  }
  static removeInBetween(str, enclosingPair) {
    if (!str) {
      throw new MetaBindInternalError("string must not be empty");
    }
    let remainingOpeningStringCount = ParserUtils.numberOfOccurrences(str, enclosingPair.openingString);
    let remainingClosingStringCount = ParserUtils.numberOfOccurrences(str, enclosingPair.closingString);
    let enclosingLevel = 0;
    let subStr = "";
    for (let i = 0; i < str.length; i++) {
      if (enclosingPair.openingEqualsClosing) {
        if (ParserUtils.isStringAt(str, enclosingPair.openingString, i)) {
          if (enclosingLevel % 2 === 0 && remainingOpeningStringCount === 1) {
          } else if (enclosingLevel % 2 === 0) {
            enclosingLevel += 1;
            i += enclosingPair.openingString.length;
            if (i >= str.length) {
              break;
            }
          } else {
            enclosingLevel -= 1;
            i += enclosingPair.closingString.length;
            if (i >= str.length) {
              break;
            }
          }
          remainingOpeningStringCount -= 1;
        }
      } else {
        if (ParserUtils.isStringAt(str, enclosingPair.openingString, i)) {
          if (remainingOpeningStringCount <= remainingClosingStringCount) {
            enclosingLevel += 1;
            i += enclosingPair.openingString.length;
            if (i >= str.length) {
              break;
            }
          }
          remainingOpeningStringCount -= 1;
        } else if (ParserUtils.isStringAt(str, enclosingPair.closingString, i)) {
          if (enclosingLevel > 0) {
            enclosingLevel -= 1;
            i += enclosingPair.closingString.length;
            if (i >= str.length) {
              break;
            }
          }
          remainingClosingStringCount -= 1;
        }
      }
      if (enclosingLevel === 0) {
        subStr += str[i];
      }
    }
    return subStr;
  }
  static getInBetween(str, enclosingPair) {
    if (!str) {
      throw new MetaBindInternalError("string must not be empty");
    }
    let remainingOpeningStringCount = ParserUtils.numberOfOccurrences(str, enclosingPair.openingString);
    let remainingClosingStringCount = ParserUtils.numberOfOccurrences(str, enclosingPair.closingString);
    let enclosingLevel = 0;
    let subStr = "";
    let subStrings = [];
    strLoop:
      for (let i = 0; i < str.length; i++) {
        if (enclosingPair.openingEqualsClosing) {
          if (ParserUtils.isStringAt(str, enclosingPair.openingString, i)) {
            if (enclosingLevel % 2 === 0 && remainingOpeningStringCount === 1) {
            } else if (enclosingLevel % 2 === 0) {
              enclosingLevel += 1;
              subStr += str[i];
              for (let j = 1; j < enclosingPair.openingString.length; j++) {
                i += 1;
                subStr += str[i];
                if (i >= str.length) {
                  break strLoop;
                }
              }
            } else {
              enclosingLevel -= 1;
              subStr += str[i];
              for (let j = 1; j < enclosingPair.closingString.length; j++) {
                i += 1;
                subStr += str[i];
                if (i > str.length) {
                  break strLoop;
                }
              }
              subStrings.push(subStr);
              subStr = "";
            }
            remainingOpeningStringCount -= 1;
          } else {
            if (enclosingLevel >= 1) {
              subStr += str[i];
            }
          }
        } else {
          if (ParserUtils.isStringAt(str, enclosingPair.openingString, i)) {
            if (remainingOpeningStringCount <= remainingClosingStringCount) {
              enclosingLevel += 1;
              subStr += str[i];
              for (let j = 1; j < enclosingPair.openingString.length; j++) {
                i += 1;
                subStr += str[i];
                if (i >= str.length) {
                  break strLoop;
                }
              }
            }
            remainingOpeningStringCount -= 1;
          } else if (ParserUtils.isStringAt(str, enclosingPair.closingString, i)) {
            if (enclosingLevel > 0) {
              enclosingLevel -= 1;
              subStr += str[i];
              for (let j = 1; j < enclosingPair.closingString.length; j++) {
                i += 1;
                subStr += str[i];
                if (i > str.length) {
                  break strLoop;
                }
              }
              if (enclosingLevel === 0) {
                subStrings.push(subStr);
                subStr = "";
              }
            }
            remainingClosingStringCount -= 1;
          } else {
            if (enclosingLevel >= 1) {
              subStr += str[i];
            }
          }
        }
      }
    if (subStrings.length === 0) {
      return "";
    } else if (subStrings.length === 1) {
      return subStrings[0].substring(enclosingPair.openingString.length, subStrings[0].length - enclosingPair.closingString.length);
    } else {
      return subStrings.map((x) => x.substring(enclosingPair.openingString.length, x.length - enclosingPair.closingString.length));
    }
  }
  static isStringAt(str, subStr, index) {
    if (index < 0) {
      throw new MetaBindInternalError("index must be greater than 0");
    }
    if (index >= str.length) {
      throw new MetaBindInternalError("index out of bounds of string");
    }
    if (!str) {
      throw new MetaBindInternalError("string must not be empty");
    }
    if (!subStr) {
      throw new MetaBindInternalError("sub string must not be empty");
    }
    for (let i = 0; i < subStr.length; i++) {
      if (str[i + index] !== subStr[i]) {
        return false;
      }
    }
    return true;
  }
  static contains(str, subStr) {
    return ParserUtils.numberOfOccurrences(str, subStr) > 0;
  }
  static numberOfOccurrences(str, subStr) {
    if (!str) {
      throw new MetaBindInternalError("string must not be empty");
    }
    if (!subStr) {
      throw new MetaBindInternalError("sub string must not be empty");
    }
    let occurrences = 0;
    for (let i = 0; i < str.length; i++) {
      if (ParserUtils.isStringAt(str, subStr, i)) {
        occurrences += 1;
      }
    }
    return occurrences;
  }
};

// src/parsers/InputFieldDeclarationParser.ts
var InputFieldType = /* @__PURE__ */ ((InputFieldType2) => {
  InputFieldType2["TOGGLE"] = "toggle";
  InputFieldType2["SLIDER"] = "slider";
  InputFieldType2["TEXT"] = "text";
  InputFieldType2["TEXT_AREA"] = "text_area";
  InputFieldType2["SELECT"] = "select";
  InputFieldType2["MULTI_SELECT"] = "multi_select";
  InputFieldType2["DATE"] = "date";
  InputFieldType2["TIME"] = "time";
  InputFieldType2["INVALID"] = "invalid";
  return InputFieldType2;
})(InputFieldType || {});
var _InputFieldDeclarationParser = class {
  static parse(fullDeclaration) {
    var _a;
    const inputFieldDeclaration = {};
    inputFieldDeclaration.fullDeclaration = fullDeclaration;
    inputFieldDeclaration.declaration = ParserUtils.getInBetween(fullDeclaration, _InputFieldDeclarationParser.squareBracesPair);
    const declarationParts = ParserUtils.split(inputFieldDeclaration.declaration, ":", _InputFieldDeclarationParser.squareBracesPair);
    inputFieldDeclaration.bindTarget = (_a = declarationParts[1]) != null ? _a : "";
    inputFieldDeclaration.isBound = isTruthy(inputFieldDeclaration.bindTarget);
    const inputFieldTypeWithArguments = declarationParts[0];
    const inputFieldTypeString = ParserUtils.removeInBetween(inputFieldTypeWithArguments, _InputFieldDeclarationParser.roundBracesPair);
    inputFieldDeclaration.inputFieldType = _InputFieldDeclarationParser.getInputFieldType(inputFieldTypeString);
    if (inputFieldDeclaration.inputFieldType === "invalid" /* INVALID */) {
      throw new MetaBindParsingError(`unknown input field type '${inputFieldTypeString}'`);
    }
    const inputFieldArgumentsString = ParserUtils.getInBetween(inputFieldTypeWithArguments, _InputFieldDeclarationParser.roundBracesPair);
    if (inputFieldArgumentsString) {
      inputFieldDeclaration.arguments = _InputFieldDeclarationParser.parseArguments(inputFieldArgumentsString, inputFieldDeclaration.inputFieldType);
    } else {
      inputFieldDeclaration.arguments = [];
    }
    return inputFieldDeclaration;
  }
  static parseArguments(inputFieldArgumentsString, inputFieldType) {
    let inputFieldArgumentStrings = ParserUtils.split(inputFieldArgumentsString, ",", _InputFieldDeclarationParser.roundBracesPair);
    inputFieldArgumentStrings = inputFieldArgumentStrings.map((x) => x.trim());
    const inputFieldArguments = [];
    for (const inputFieldArgumentString of inputFieldArgumentStrings) {
      const inputFieldArgumentName = _InputFieldDeclarationParser.extractInputFieldArgumentName(inputFieldArgumentString);
      if (inputFieldArgumentName === "class") {
        const inputFieldArgumentValue = _InputFieldDeclarationParser.extractInputFieldArgumentValue(inputFieldArgumentString);
        let inputFieldClassArgument = { name: inputFieldArgumentName, value: inputFieldArgumentValue };
        inputFieldArguments.push(inputFieldClassArgument);
      } else if (inputFieldArgumentName === "addLabels") {
        if (inputFieldType !== "slider" /* SLIDER */) {
          throw new MetaBindParsingError(`argument '${inputFieldArgumentName}' is only applicable to slider input fields`);
        }
        inputFieldArguments.push({ name: "labels", value: true });
      } else if (inputFieldArgumentName === "minValue") {
        if (inputFieldType !== "slider" /* SLIDER */) {
          throw new MetaBindParsingError(`argument '${inputFieldArgumentName}' is only applicable to slider input fields`);
        }
        const inputFieldArgumentValue = _InputFieldDeclarationParser.extractInputFieldArgumentValue(inputFieldArgumentString);
        const inputFieldArgumentValueAsNumber = Number.parseInt(inputFieldArgumentValue);
        if (Number.isNaN(inputFieldArgumentValueAsNumber)) {
          throw new MetaBindParsingError(`argument '${inputFieldArgumentName}' value must be of type number`);
        }
        let inputFieldArgumentObject = { name: inputFieldArgumentName, value: inputFieldArgumentValueAsNumber };
        inputFieldArguments.push(inputFieldArgumentObject);
      } else if (inputFieldArgumentName === "maxValue") {
        if (inputFieldType !== "slider" /* SLIDER */) {
          throw new MetaBindParsingError(`argument '${inputFieldArgumentName}' is only applicable to slider input fields`);
        }
        const inputFieldArgumentValue = _InputFieldDeclarationParser.extractInputFieldArgumentValue(inputFieldArgumentString);
        const inputFieldArgumentValueAsNumber = Number.parseInt(inputFieldArgumentValue);
        if (Number.isNaN(inputFieldArgumentValueAsNumber)) {
          throw new MetaBindParsingError(`argument '${inputFieldArgumentName}' value must be of type number`);
        }
        let inputFieldArgumentObject = { name: inputFieldArgumentName, value: inputFieldArgumentValueAsNumber };
        inputFieldArguments.push(inputFieldArgumentObject);
      } else if (inputFieldArgumentName === "option") {
        if (inputFieldType !== "select" /* SELECT */ && inputFieldType !== "multi_select" /* MULTI_SELECT */) {
          throw new MetaBindParsingError(`argument '${inputFieldArgumentName}' is only applicable to select and multi-select input fields`);
        }
        const inputFieldArgumentValue = _InputFieldDeclarationParser.extractInputFieldArgumentValue(inputFieldArgumentString);
        let inputFieldArgumentObject = { name: inputFieldArgumentName, value: inputFieldArgumentValue };
        inputFieldArguments.push(inputFieldArgumentObject);
      } else if (inputFieldArgumentName === "title") {
        if (inputFieldType !== "select" /* SELECT */ && inputFieldType !== "multi_select" /* MULTI_SELECT */) {
          throw new MetaBindParsingError(`argument '${inputFieldArgumentName}' is only applicable to select and multi-select input fields`);
        }
        const inputFieldArgumentValue = _InputFieldDeclarationParser.extractInputFieldArgumentValue(inputFieldArgumentString);
        let inputFieldArgumentObject = { name: inputFieldArgumentName, value: inputFieldArgumentValue };
        inputFieldArguments.push(inputFieldArgumentObject);
      } else {
        throw new MetaBindParsingError(`unknown argument '${inputFieldArgumentName}'`);
      }
    }
    return inputFieldArguments;
  }
  static extractInputFieldArgumentName(argumentString) {
    return ParserUtils.removeInBetween(argumentString, _InputFieldDeclarationParser.roundBracesPair);
  }
  static extractInputFieldArgumentValue(argumentString) {
    let argumentName = this.extractInputFieldArgumentName(argumentString);
    let argumentValue = ParserUtils.getInBetween(argumentString, _InputFieldDeclarationParser.roundBracesPair);
    if (!argumentValue) {
      throw new MetaBindParsingError(`argument '${argumentName}' requires a non empty value`);
    }
    return argumentValue;
  }
  static getInputFieldType(str) {
    for (const entry of Object.entries(InputFieldType)) {
      if (entry[1] === str) {
        return entry[1];
      }
    }
    return "invalid" /* INVALID */;
  }
};
var InputFieldDeclarationParser = _InputFieldDeclarationParser;
InputFieldDeclarationParser.roundBracesPair = new EnclosingPair("(", ")");
InputFieldDeclarationParser.squareBracesPair = new EnclosingPair("[", "]");
InputFieldDeclarationParser.curlyBracesPair = new EnclosingPair("{", "}");
InputFieldDeclarationParser.allBracesPairs = [
  _InputFieldDeclarationParser.roundBracesPair,
  _InputFieldDeclarationParser.squareBracesPair,
  _InputFieldDeclarationParser.curlyBracesPair
];

// src/inputFields/InputFieldFactory.ts
var _InputFieldFactory = class {
  static createInputField(inputFieldType, args) {
    if (inputFieldType === "toggle" /* TOGGLE */) {
      _InputFieldFactory.checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, args.type);
      return new ToggleInputField(args.inputFieldMarkdownRenderChild, args.onValueChanged);
    } else if (inputFieldType === "slider" /* SLIDER */) {
      _InputFieldFactory.checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, args.type);
      return new SliderInputField(args.inputFieldMarkdownRenderChild, args.onValueChanged);
    } else if (inputFieldType === "text" /* TEXT */) {
      _InputFieldFactory.checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, args.type);
      return new TextInputField(args.inputFieldMarkdownRenderChild, args.onValueChanged);
    } else if (inputFieldType === "text_area" /* TEXT_AREA */) {
      _InputFieldFactory.checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, args.type);
      return new TextAreaInputField(args.inputFieldMarkdownRenderChild, args.onValueChanged);
    } else if (inputFieldType === "select" /* SELECT */) {
      _InputFieldFactory.checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, args.type);
      return new SelectInputField(args.inputFieldMarkdownRenderChild, args.onValueChanged);
    } else if (inputFieldType === "multi_select" /* MULTI_SELECT */) {
      _InputFieldFactory.checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, args.type);
      return new MultiSelectInputField(args.inputFieldMarkdownRenderChild, args.onValueChanged);
    } else if (inputFieldType === "date" /* DATE */) {
      _InputFieldFactory.checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, args.type);
      return new DateInputField(args.inputFieldMarkdownRenderChild, args.onValueChanged);
    } else if (inputFieldType === "time" /* TIME */) {
      _InputFieldFactory.checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, args.type);
      return new TimeInputField(args.inputFieldMarkdownRenderChild, args.onValueChanged);
    }
    return null;
  }
  static checkInputFieldMarkdownRenderChildTypeAllowed(inputFieldType, type) {
    const allowCodeBlock = _InputFieldFactory.allowCodeBlockMap[inputFieldType];
    if (type === 1 /* CODE_BLOCK */ && !allowCodeBlock.codeBlock) {
      throw new MetaBindParsingError(`'${inputFieldType}' is not allowed as code block`);
    }
    if (type === 0 /* INLINE_CODE_BLOCK */ && !allowCodeBlock.inlineCodeBlock) {
      throw new MetaBindParsingError(`'${inputFieldType}' is not allowed as inline code block`);
    }
  }
};
var InputFieldFactory = _InputFieldFactory;
InputFieldFactory.allowCodeBlockMap = {
  ["toggle" /* TOGGLE */]: { codeBlock: ToggleInputField.allowCodeBlock, inlineCodeBlock: ToggleInputField.allowInlineCodeBlock },
  ["slider" /* SLIDER */]: { codeBlock: SliderInputField.allowCodeBlock, inlineCodeBlock: SliderInputField.allowInlineCodeBlock },
  ["text" /* TEXT */]: { codeBlock: TextInputField.allowCodeBlock, inlineCodeBlock: TextInputField.allowInlineCodeBlock },
  ["text_area" /* TEXT_AREA */]: { codeBlock: TextAreaInputField.allowCodeBlock, inlineCodeBlock: TextAreaInputField.allowInlineCodeBlock },
  ["select" /* SELECT */]: { codeBlock: SelectInputField.allowCodeBlock, inlineCodeBlock: SelectInputField.allowInlineCodeBlock },
  ["multi_select" /* MULTI_SELECT */]: { codeBlock: MultiSelectInputField.allowCodeBlock, inlineCodeBlock: MultiSelectInputField.allowInlineCodeBlock },
  ["date" /* DATE */]: { codeBlock: DateInputField.allowCodeBlock, inlineCodeBlock: DateInputField.allowInlineCodeBlock },
  ["time" /* TIME */]: { codeBlock: TimeInputField.allowCodeBlock, inlineCodeBlock: TimeInputField.allowInlineCodeBlock }
};

// src/InputFieldMarkdownRenderChild.ts
var InputFieldMarkdownRenderChild2 = class extends import_obsidian8.MarkdownRenderChild {
  constructor(containerEl, type, fullDeclaration, plugin, filePath, uid) {
    super(containerEl);
    this.error = "";
    this.filePath = filePath;
    this.uid = uid;
    this.plugin = plugin;
    this.valueQueue = [];
    this.intervalCounter = 0;
    this.limitInterval = window.setInterval(() => this.applyValueQueueToMetadata(), this.plugin.settings.syncInterval);
    try {
      this.inputFieldDeclaration = InputFieldDeclarationParser.parse(fullDeclaration);
      if (this.inputFieldDeclaration.isBound) {
        this.parseBindTarget();
        this.metaData = this.plugin.getMetaDataForFile(this.bindTargetFile);
      }
      this.inputField = InputFieldFactory.createInputField(this.inputFieldDeclaration.inputFieldType, {
        type,
        inputFieldMarkdownRenderChild: this,
        onValueChanged: this.pushToValueQueue.bind(this)
      });
    } catch (e) {
      this.error = e.message;
      Logger.logWarning(e);
    }
  }
  parseBindTarget() {
    let bindTargetParts = this.inputFieldDeclaration.bindTarget.split("#");
    if (bindTargetParts.length === 1) {
      this.bindTargetMetadataField = this.inputFieldDeclaration.bindTarget;
      const files = this.plugin.getFilesByName(this.filePath);
      if (files.length === 0) {
        throw new MetaBindBindTargetError("bind target file not found");
      } else if (files.length === 1) {
        this.bindTargetFile = files[0];
      } else {
        throw new MetaBindBindTargetError("bind target resolves to multiple files; please also specify the file path");
      }
    } else if (bindTargetParts.length === 2) {
      this.bindTargetMetadataField = bindTargetParts[1];
      const files = this.plugin.getFilesByName(bindTargetParts[0]);
      if (files.length === 0) {
        throw new MetaBindBindTargetError("bind target file not found");
      } else if (files.length === 1) {
        this.bindTargetFile = files[0];
      } else {
        throw new MetaBindBindTargetError("bind target resolves to multiple files; please also specify the file path");
      }
    } else {
      throw new MetaBindBindTargetError("bind target may only contain one '#' to specify the metadata field");
    }
  }
  applyValueQueueToMetadata() {
    return __async(this, null, function* () {
      if (this.valueQueue.length > 0) {
        yield this.plugin.updateMetaData(this.bindTargetMetadataField, this.valueQueue.at(-1), this.bindTargetFile);
        this.valueQueue = [];
      }
    });
  }
  pushToValueQueue(value) {
    return __async(this, null, function* () {
      if (this.inputFieldDeclaration.isBound) {
        this.valueQueue.push(value);
      }
    });
  }
  updateValue(value) {
    if (value == null) {
      value = this.inputField.getDefaultValue();
    }
    if (!this.inputField.isEqualValue(value) && this.valueQueue.length === 0) {
      Logger.logDebug(`updating input field ${this.uid} to`, value);
      this.inputField.setValue(value);
    }
  }
  getInitialValue() {
    var _a;
    if (this.inputFieldDeclaration.isBound) {
      return (_a = this.metaData[this.bindTargetMetadataField]) != null ? _a : this.inputField.getDefaultValue();
    }
  }
  getArguments(name) {
    return this.inputFieldDeclaration.arguments.filter((x) => x.name === name);
  }
  getArgument(name) {
    return this.getArguments(name).first();
  }
  onload() {
    return __async(this, null, function* () {
      Logger.logDebug("load", this);
      this.metaData = yield this.metaData;
      const container = this.containerEl.createDiv();
      container.addClass("meta-bind-plugin-input-wrapper");
      this.containerEl.addClass("meta-bind-plugin-input");
      if (this.error) {
        container.innerText = ` -> ERROR: ${this.error}`;
        container.addClass("meta-bind-plugin-error");
        this.containerEl.appendChild(container);
        return;
      }
      this.plugin.registerMarkdownInputField(this);
      this.inputField.render(container);
      const classArgument = this.getArguments("class");
      if (classArgument) {
        this.inputField.getHtmlElement().addClasses(classArgument.map((x) => x.value));
      }
      this.containerEl.empty();
      this.containerEl.appendChild(container);
    });
  }
  onunload() {
    Logger.logDebug("unload", this);
    this.plugin.unregisterMarkdownInputField(this);
    super.onunload();
    window.clearInterval(this.limitInterval);
  }
};

// src/main.ts
var MetaBindPlugin = class extends import_obsidian9.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      Logger.devMode = this.settings.devMode;
      DateParser.dateFormat = this.settings.dateFormat;
      this.activeMarkdownInputFields = [];
      this.markDownInputFieldIndex = 0;
      this.registerMarkdownPostProcessor((element, context) => {
        const codeBlocks = element.querySelectorAll("code");
        for (let index = 0; index < codeBlocks.length; index++) {
          const codeBlock = codeBlocks.item(index);
          const text = codeBlock.innerText;
          const isInputField = text.startsWith("INPUT[") && text.endsWith("]");
          if (isInputField) {
            context.addChild(new InputFieldMarkdownRenderChild2(codeBlock, 0 /* INLINE_CODE_BLOCK */, text, this, context.sourcePath, this.markDownInputFieldIndex));
            this.markDownInputFieldIndex += 1;
          }
        }
      });
      this.registerMarkdownCodeBlockProcessor("meta-bind", (source, el, ctx) => {
        const codeBlock = el;
        const text = source.replace(/\n/g, "");
        const isInputField = text.startsWith("INPUT[") && text.endsWith("]");
        if (isInputField) {
          ctx.addChild(new InputFieldMarkdownRenderChild2(codeBlock, 1 /* CODE_BLOCK */, text, this, ctx.sourcePath, this.markDownInputFieldIndex));
          this.markDownInputFieldIndex += 1;
        }
      });
      this.registerEvent(this.app.vault.on("modify", (abstractFile) => __async(this, null, function* () {
        if (abstractFile instanceof import_obsidian9.TFile) {
          yield this.updateMarkdownInputFieldsOnFileChange(abstractFile);
        }
      })));
      this.addSettingTab(new MetaBindSettingTab(this.app, this));
    });
  }
  onunload() {
    for (const activeMarkdownInputField of this.activeMarkdownInputFields) {
      activeMarkdownInputField.unload();
    }
  }
  registerMarkdownInputField(markdownInputField) {
    this.activeMarkdownInputFields.push(markdownInputField);
  }
  unregisterMarkdownInputField(markdownInputField) {
    this.activeMarkdownInputFields = this.activeMarkdownInputFields.filter((x) => x.uid !== markdownInputField.uid);
  }
  updateMarkdownInputFieldsOnFileChange(file) {
    return __async(this, null, function* () {
      let metadata = void 0;
      for (const activeMarkdownInputField of this.activeMarkdownInputFields) {
        if (!activeMarkdownInputField.bindTargetFile || !activeMarkdownInputField.inputFieldDeclaration.isBound) {
          continue;
        }
        if (activeMarkdownInputField.bindTargetFile.path === file.path) {
          if (metadata === void 0) {
            metadata = yield this.getMetaDataForFile(file);
          }
          activeMarkdownInputField.updateValue(metadata[activeMarkdownInputField.bindTargetMetadataField]);
        }
      }
    });
  }
  updateMetaData(key, value, file) {
    return __async(this, null, function* () {
      Logger.logDebug(`updating `, key, `: `, value, ` in '${file.path}'`);
      if (!file) {
        console.log("no file");
        return;
      }
      let fileContent = yield this.app.vault.read(file);
      const regExp = new RegExp("^(---)\\n[\\s\\S]*\\n---");
      fileContent = fileContent.replace(regExp, "");
      let metadata = yield this.getMetaDataForFile(file);
      if (!metadata) {
        return;
      }
      metadata[key] = value;
      fileContent = `---
${(0, import_obsidian9.stringifyYaml)(metadata)}---` + fileContent;
      yield this.app.vault.modify(file, fileContent);
    });
  }
  getFilesByName(name) {
    const fileNameIsPath = isPath(name);
    let processedFileName = fileNameIsPath ? removeFileEnding(name) : getFileName(removeFileEnding(name));
    const allFiles = this.app.vault.getFiles();
    const files = [];
    for (const file of allFiles) {
      if (fileNameIsPath) {
        if (removeFileEnding(file.path) === processedFileName) {
          files.push(file);
        }
      } else {
        if (getFileName(removeFileEnding(file.name)) === processedFileName) {
          files.push(file);
        }
      }
    }
    return files;
  }
  getMetaDataForFile(file) {
    return __async(this, null, function* () {
      let metadata;
      let fileContent = yield this.app.vault.read(file);
      const regExp = new RegExp("^(---)\\n[\\s\\S]*\\n---");
      let frontMatterRegExpResult = regExp.exec(fileContent);
      if (!frontMatterRegExpResult) {
        return {};
      }
      let frontMatter = frontMatterRegExpResult[0];
      if (!frontMatter) {
        return {};
      }
      frontMatter = frontMatter.substring(4);
      frontMatter = frontMatter.substring(0, frontMatter.length - 3);
      metadata = (0, import_obsidian9.parseYaml)(frontMatter);
      if (!metadata) {
        metadata = {};
      }
      return metadata;
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      DateParser.dateFormat = this.settings.dateFormat;
      Logger.devMode = this.settings.devMode;
      yield this.saveData(this.settings);
    });
  }
};
